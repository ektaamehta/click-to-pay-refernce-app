/*
 * Click to Pay Checkout API
 * Checkout end point used by Click to Pay Integrators to receive payload data from the Mastercard Checkout Solutions and send the results of transaction authorization back to the Mastercard. Endpoints are available to retrieve payload data and send the outcome of a payment or checkout.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: apisupport@mastercard.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.mcs.clicktopay.checkout.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.mcs.clicktopay.checkout.model.PhoneNumber;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.mcs.clicktopay.checkout.invoker.JSON;

/**
 * Object will be used to help issuers with their risk decisioning or dispute resolution. The provisioning of data is subject to compliance with all applicable laws and regulations.
 */
@com.fasterxml.jackson.annotation.JsonInclude(com.fasterxml.jackson.annotation.JsonInclude.Include.NON_NULL)
@com.fasterxml.jackson.annotation.JsonIgnoreProperties(ignoreUnknown = true)
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-08-04T20:17:01.464095077Z[Etc/UTC]")
public class DigitalTransactionData {
  public static final String SERIALIZED_NAME_PHONE_NUMBER = "phoneNumber";
  @SerializedName(SERIALIZED_NAME_PHONE_NUMBER)
  private PhoneNumber phoneNumber;

  public static final String SERIALIZED_NAME_EMAIL_ADDRESS_FORMAT = "emailAddressFormat";
  @SerializedName(SERIALIZED_NAME_EMAIL_ADDRESS_FORMAT)
  private Integer emailAddressFormat;

  public static final String SERIALIZED_NAME_EMAIL_ADDRESS = "emailAddress";
  @SerializedName(SERIALIZED_NAME_EMAIL_ADDRESS)
  private String emailAddress;

  public static final String SERIALIZED_NAME_DEVICE_LOCATION = "deviceLocation";
  @SerializedName(SERIALIZED_NAME_DEVICE_LOCATION)
  private String deviceLocation;

  public static final String SERIALIZED_NAME_IP_ADDRESS = "ipAddress";
  @SerializedName(SERIALIZED_NAME_IP_ADDRESS)
  private String ipAddress;

  public DigitalTransactionData() {
  }

  public DigitalTransactionData phoneNumber(PhoneNumber phoneNumber) {
    this.phoneNumber = phoneNumber;
    return this;
  }

   /**
   * Get phoneNumber
   * @return phoneNumber
  **/
  @jakarta.annotation.Nullable
  public PhoneNumber getPhoneNumber() {
    return phoneNumber;
  }

  public void setPhoneNumber(PhoneNumber phoneNumber) {
    this.phoneNumber = phoneNumber;
  }


  public DigitalTransactionData emailAddressFormat(Integer emailAddressFormat) {
    this.emailAddressFormat = emailAddressFormat;
    return this;
  }

   /**
   * This parameter indicates if an email address is clear or hashed email address collected during checkout. Required when the email address is provided. Possible values are: &#39;0&#39; - Clear / Plain email address &#39;1&#39; - Hashed email address
   * @return emailAddressFormat
  **/
  @jakarta.annotation.Nullable
  public Integer getEmailAddressFormat() {
    return emailAddressFormat;
  }

  public void setEmailAddressFormat(Integer emailAddressFormat) {
    this.emailAddressFormat = emailAddressFormat;
  }


  public DigitalTransactionData emailAddress(String emailAddress) {
    this.emailAddress = emailAddress;
    return this;
  }

   /**
   * CardHolder&#39;s email Address. In case of hashed email address use SHA256 Algorithm. Refer to Appendix B TAF Program Guide for more details. Conditional : Required for Token Authentication Framework. Mandatory if no phone number is provided.
   * @return emailAddress
  **/
  @jakarta.annotation.Nullable
  public String getEmailAddress() {
    return emailAddress;
  }

  public void setEmailAddress(String emailAddress) {
    this.emailAddress = emailAddress;
  }


  public DigitalTransactionData deviceLocation(String deviceLocation) {
    this.deviceLocation = deviceLocation;
    return this;
  }

   /**
   * This field should contain the latitude and longitude coordinates of the device where consumer is attempting to checkout. It&#39;s formatted as first 8 digits are latitude &amp; longitude hexadecimal encoded degree with two decimal places and last digit is latitude &amp; longitude sector value from one of the values (1:NW 2:NE 3SW 4SE). Conditional : Required for Token Authentication Framework unless the consumer has declined to share his/her location.
   * @return deviceLocation
  **/
  @jakarta.annotation.Nullable
  public String getDeviceLocation() {
    return deviceLocation;
  }

  public void setDeviceLocation(String deviceLocation) {
    this.deviceLocation = deviceLocation;
  }


  public DigitalTransactionData ipAddress(String ipAddress) {
    this.ipAddress = ipAddress;
    return this;
  }

   /**
   * Unique string of characters that identifies a device. Support V4 or V6 Conditional : Required for Token Authentication Framework
   * @return ipAddress
  **/
  @jakarta.annotation.Nullable
  public String getIpAddress() {
    return ipAddress;
  }

  public void setIpAddress(String ipAddress) {
    this.ipAddress = ipAddress;
  }

  /**
   * A container for additional, undeclared properties.
   * This is a holder for any undeclared properties as specified with
   * the 'additionalProperties' keyword in the OAS document.
   */
  private Map<String, Object> additionalProperties;

  /**
   * Set the additional (undeclared) property with the specified name and value.
   * If the property does not already exist, create it otherwise replace it.
   *
   * @param key name of the property
   * @param value value of the property
   * @return the DigitalTransactionData instance itself
   */
  public DigitalTransactionData putAdditionalProperty(String key, Object value) {
    if (this.additionalProperties == null) {
        this.additionalProperties = new HashMap<String, Object>();
    }
    this.additionalProperties.put(key, value);
    return this;
  }

  /**
   * Return the additional (undeclared) property.
   *
   * @return a map of objects
   */
  public Map<String, Object> getAdditionalProperties() {
    return additionalProperties;
  }

  /**
   * Return the additional (undeclared) property with the specified name.
   *
   * @param key name of the property
   * @return an object
   */
  public Object getAdditionalProperty(String key) {
    if (this.additionalProperties == null) {
        return null;
    }
    return this.additionalProperties.get(key);
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DigitalTransactionData digitalTransactionData = (DigitalTransactionData) o;
    return Objects.equals(this.phoneNumber, digitalTransactionData.phoneNumber) &&
        Objects.equals(this.emailAddressFormat, digitalTransactionData.emailAddressFormat) &&
        Objects.equals(this.emailAddress, digitalTransactionData.emailAddress) &&
        Objects.equals(this.deviceLocation, digitalTransactionData.deviceLocation) &&
        Objects.equals(this.ipAddress, digitalTransactionData.ipAddress)&&
        Objects.equals(this.additionalProperties, digitalTransactionData.additionalProperties);
  }

  @Override
  public int hashCode() {
    return Objects.hash(phoneNumber, emailAddressFormat, emailAddress, deviceLocation, ipAddress, additionalProperties);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DigitalTransactionData {\n");
    sb.append("    phoneNumber: ").append(toIndentedString(phoneNumber)).append("\n");
    sb.append("    emailAddressFormat: ").append(toIndentedString(emailAddressFormat)).append("\n");
    sb.append("    emailAddress: ").append(toIndentedString(emailAddress)).append("\n");
    sb.append("    deviceLocation: ").append(toIndentedString(deviceLocation)).append("\n");
    sb.append("    ipAddress: ").append(toIndentedString(ipAddress)).append("\n");
    sb.append("    additionalProperties: ").append(toIndentedString(additionalProperties)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("phoneNumber");
    openapiFields.add("emailAddressFormat");
    openapiFields.add("emailAddress");
    openapiFields.add("deviceLocation");
    openapiFields.add("ipAddress");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to DigitalTransactionData
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!DigitalTransactionData.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DigitalTransactionData is not found in the empty JSON string", DigitalTransactionData.openapiRequiredFields.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `phoneNumber`
      if (jsonObj.get("phoneNumber") != null && !jsonObj.get("phoneNumber").isJsonNull()) {
        PhoneNumber.validateJsonElement(jsonObj.get("phoneNumber"));
      }
      if ((jsonObj.get("emailAddress") != null && !jsonObj.get("emailAddress").isJsonNull()) && !jsonObj.get("emailAddress").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `emailAddress` to be a primitive type in the JSON string but got `%s`", jsonObj.get("emailAddress").toString()));
      }
      if ((jsonObj.get("deviceLocation") != null && !jsonObj.get("deviceLocation").isJsonNull()) && !jsonObj.get("deviceLocation").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `deviceLocation` to be a primitive type in the JSON string but got `%s`", jsonObj.get("deviceLocation").toString()));
      }
      if ((jsonObj.get("ipAddress") != null && !jsonObj.get("ipAddress").isJsonNull()) && !jsonObj.get("ipAddress").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ipAddress` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ipAddress").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DigitalTransactionData.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DigitalTransactionData' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DigitalTransactionData> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DigitalTransactionData.class));

       return (TypeAdapter<T>) new TypeAdapter<DigitalTransactionData>() {
           @Override
           public void write(JsonWriter out, DigitalTransactionData value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             obj.remove("additionalProperties");
             // serialize additional properties
             if (value.getAdditionalProperties() != null) {
               for (Map.Entry<String, Object> entry : value.getAdditionalProperties().entrySet()) {
                 if (entry.getValue() instanceof String)
                   obj.addProperty(entry.getKey(), (String) entry.getValue());
                 else if (entry.getValue() instanceof Number)
                   obj.addProperty(entry.getKey(), (Number) entry.getValue());
                 else if (entry.getValue() instanceof Boolean)
                   obj.addProperty(entry.getKey(), (Boolean) entry.getValue());
                 else if (entry.getValue() instanceof Character)
                   obj.addProperty(entry.getKey(), (Character) entry.getValue());
                 else {
                   JsonElement jsonElement = gson.toJsonTree(entry.getValue());
                   if (jsonElement.isJsonArray()) {
                     obj.add(entry.getKey(), jsonElement.getAsJsonArray());
                   } else {
                     obj.add(entry.getKey(), jsonElement.getAsJsonObject());
                   }
                 }
               }
             }
             elementAdapter.write(out, obj);
           }

           @Override
           public DigitalTransactionData read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             JsonObject jsonObj = jsonElement.getAsJsonObject();
             // store additional fields in the deserialized instance
             DigitalTransactionData instance = thisAdapter.fromJsonTree(jsonObj);
             for (Map.Entry<String, JsonElement> entry : jsonObj.entrySet()) {
               if (!openapiFields.contains(entry.getKey())) {
                 if (entry.getValue().isJsonPrimitive()) { // primitive type
                   if (entry.getValue().getAsJsonPrimitive().isString())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsString());
                   else if (entry.getValue().getAsJsonPrimitive().isNumber())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsNumber());
                   else if (entry.getValue().getAsJsonPrimitive().isBoolean())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsBoolean());
                   else
                     throw new IllegalArgumentException(String.format("The field `%s` has unknown primitive type. Value: %s", entry.getKey(), entry.getValue().toString()));
                 } else if (entry.getValue().isJsonArray()) {
                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), List.class));
                 } else { // JSON object
                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), HashMap.class));
                 }
               }
             }
             return instance;
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of DigitalTransactionData given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of DigitalTransactionData
  * @throws IOException if the JSON string is invalid with respect to DigitalTransactionData
  */
  public static DigitalTransactionData fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DigitalTransactionData.class);
  }

 /**
  * Convert an instance of DigitalTransactionData to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

