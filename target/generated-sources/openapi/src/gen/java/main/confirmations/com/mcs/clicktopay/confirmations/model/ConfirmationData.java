/*
 * Confirmations API
 * Click to Pay checkout used by SRC Initiators to receive payload data from the Click to Pay System and send the results of transaction authorisation back to the Click to Pay System. Endpoints are available to retrieve payload data and send the outcome of a payment or checkout. Refer to the EMVCo-Secure-Remote-Commerce-Specifications-API-1.0
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: apisupport@mastercard.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.mcs.clicktopay.confirmations.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.mcs.clicktopay.confirmations.model.AssuranceData;
import com.mcs.clicktopay.confirmations.model.TransactionAmount;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.mcs.clicktopay.confirmations.invoker.JSON;

/**
 * ConfirmationData
 */
@com.fasterxml.jackson.annotation.JsonInclude(com.fasterxml.jackson.annotation.JsonInclude.Include.NON_NULL)
@com.fasterxml.jackson.annotation.JsonIgnoreProperties(ignoreUnknown = true)
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-08-04T20:17:03.225795086Z[Etc/UTC]")
public class ConfirmationData {
  public static final String SERIALIZED_NAME_CHECKOUT_EVENT_TYPE = "checkoutEventType";
  @SerializedName(SERIALIZED_NAME_CHECKOUT_EVENT_TYPE)
  private String checkoutEventType;

  public static final String SERIALIZED_NAME_CHECKOUT_EVENT_STATUS = "checkoutEventStatus";
  @SerializedName(SERIALIZED_NAME_CHECKOUT_EVENT_STATUS)
  private String checkoutEventStatus;

  public static final String SERIALIZED_NAME_CONFIRMATION_STATUS = "confirmationStatus";
  @SerializedName(SERIALIZED_NAME_CONFIRMATION_STATUS)
  private String confirmationStatus;

  public static final String SERIALIZED_NAME_CONFIRMATION_REASON = "confirmationReason";
  @SerializedName(SERIALIZED_NAME_CONFIRMATION_REASON)
  private String confirmationReason;

  public static final String SERIALIZED_NAME_CONFIRMATION_TIMESTAMP = "confirmationTimestamp";
  @SerializedName(SERIALIZED_NAME_CONFIRMATION_TIMESTAMP)
  private String confirmationTimestamp;

  public static final String SERIALIZED_NAME_NETWORK_AUTHORIZATION_CODE = "networkAuthorizationCode";
  @SerializedName(SERIALIZED_NAME_NETWORK_AUTHORIZATION_CODE)
  private String networkAuthorizationCode;

  public static final String SERIALIZED_NAME_NETWORK_TRANSACTION_IDENTIFIER = "networkTransactionIdentifier";
  @SerializedName(SERIALIZED_NAME_NETWORK_TRANSACTION_IDENTIFIER)
  private String networkTransactionIdentifier;

  public static final String SERIALIZED_NAME_PAYMENT_NETWORK_REFERENCE = "paymentNetworkReference";
  @SerializedName(SERIALIZED_NAME_PAYMENT_NETWORK_REFERENCE)
  private String paymentNetworkReference;

  public static final String SERIALIZED_NAME_ASSURANCE_DATA = "assuranceData";
  @SerializedName(SERIALIZED_NAME_ASSURANCE_DATA)
  private AssuranceData assuranceData;

  public static final String SERIALIZED_NAME_TRANSACTION_AMOUNT = "transactionAmount";
  @SerializedName(SERIALIZED_NAME_TRANSACTION_AMOUNT)
  private TransactionAmount transactionAmount;

  public ConfirmationData() {
  }

  public ConfirmationData checkoutEventType(String checkoutEventType) {
    this.checkoutEventType = checkoutEventType;
    return this;
  }

   /**
   * Type of event associated with the checkout. Valid values are: - 01 - Authorise - 02 - Capture - 03 - Refund - 04 - Cancel - 05 - Fraud - 06 - Chargeback - 07 - Other
   * @return checkoutEventType
  **/
  @jakarta.annotation.Nonnull
  public String getCheckoutEventType() {
    return checkoutEventType;
  }

  public void setCheckoutEventType(String checkoutEventType) {
    this.checkoutEventType = checkoutEventType;
  }


  public ConfirmationData checkoutEventStatus(String checkoutEventStatus) {
    this.checkoutEventStatus = checkoutEventStatus;
    return this;
  }

   /**
   *  Event type associated with the order. Valid values are: - 01 - Created - 02 - Confirmed - 03 - Cancelled - 04 - Fraud Cancelled - 05 - Others - 06-50 - Reserved for EMVCo future use - 51-99 - Click to Pay System specific statuses
   * @return checkoutEventStatus
  **/
  @jakarta.annotation.Nonnull
  public String getCheckoutEventStatus() {
    return checkoutEventStatus;
  }

  public void setCheckoutEventStatus(String checkoutEventStatus) {
    this.checkoutEventStatus = checkoutEventStatus;
  }


  public ConfirmationData confirmationStatus(String confirmationStatus) {
    this.confirmationStatus = confirmationStatus;
    return this;
  }

   /**
   * Status of the event as provided by the SRC Initiator in the confirmation message. Valid values are: - 01 - Success - 02 - Failure - 03 - Other
   * @return confirmationStatus
  **/
  @jakarta.annotation.Nullable
  public String getConfirmationStatus() {
    return confirmationStatus;
  }

  public void setConfirmationStatus(String confirmationStatus) {
    this.confirmationStatus = confirmationStatus;
  }


  public ConfirmationData confirmationReason(String confirmationReason) {
    this.confirmationReason = confirmationReason;
    return this;
  }

   /**
   * Reason for the event associated with the order.
   * @return confirmationReason
  **/
  @jakarta.annotation.Nullable
  public String getConfirmationReason() {
    return confirmationReason;
  }

  public void setConfirmationReason(String confirmationReason) {
    this.confirmationReason = confirmationReason;
  }


  public ConfirmationData confirmationTimestamp(String confirmationTimestamp) {
    this.confirmationTimestamp = confirmationTimestamp;
    return this;
  }

   /**
   * Date and time (UTC) corresponding to the completion of confirmation event by the SRC Initiator. UTC ISO 8601
   * @return confirmationTimestamp
  **/
  @jakarta.annotation.Nonnull
  public String getConfirmationTimestamp() {
    return confirmationTimestamp;
  }

  public void setConfirmationTimestamp(String confirmationTimestamp) {
    this.confirmationTimestamp = confirmationTimestamp;
  }


  public ConfirmationData networkAuthorizationCode(String networkAuthorizationCode) {
    this.networkAuthorizationCode = networkAuthorizationCode;
    return this;
  }

   /**
   * Authorisation code associated with an approved transaction.
   * @return networkAuthorizationCode
  **/
  @jakarta.annotation.Nullable
  public String getNetworkAuthorizationCode() {
    return networkAuthorizationCode;
  }

  public void setNetworkAuthorizationCode(String networkAuthorizationCode) {
    this.networkAuthorizationCode = networkAuthorizationCode;
  }


  public ConfirmationData networkTransactionIdentifier(String networkTransactionIdentifier) {
    this.networkTransactionIdentifier = networkTransactionIdentifier;
    return this;
  }

   /**
   * The unique authorisation related tracing value assigned by a Payment Network and provided in an authorisation response. Required only when checkoutEventType&#x3D;01. If checkoutEventType&#x3D;01 and the value of networkTransactionIdentifier is unknown, please pass UNAVLB.
   * @return networkTransactionIdentifier
  **/
  @jakarta.annotation.Nullable
  public String getNetworkTransactionIdentifier() {
    return networkTransactionIdentifier;
  }

  public void setNetworkTransactionIdentifier(String networkTransactionIdentifier) {
    this.networkTransactionIdentifier = networkTransactionIdentifier;
  }


  public ConfirmationData paymentNetworkReference(String paymentNetworkReference) {
    this.paymentNetworkReference = paymentNetworkReference;
    return this;
  }

   /**
   * Transaction ID provided by a Payment Network after the authorisation is complete.
   * @return paymentNetworkReference
  **/
  @jakarta.annotation.Nullable
  public String getPaymentNetworkReference() {
    return paymentNetworkReference;
  }

  public void setPaymentNetworkReference(String paymentNetworkReference) {
    this.paymentNetworkReference = paymentNetworkReference;
  }


  public ConfirmationData assuranceData(AssuranceData assuranceData) {
    this.assuranceData = assuranceData;
    return this;
  }

   /**
   * Get assuranceData
   * @return assuranceData
  **/
  @jakarta.annotation.Nullable
  public AssuranceData getAssuranceData() {
    return assuranceData;
  }

  public void setAssuranceData(AssuranceData assuranceData) {
    this.assuranceData = assuranceData;
  }


  public ConfirmationData transactionAmount(TransactionAmount transactionAmount) {
    this.transactionAmount = transactionAmount;
    return this;
  }

   /**
   * Get transactionAmount
   * @return transactionAmount
  **/
  @jakarta.annotation.Nullable
  public TransactionAmount getTransactionAmount() {
    return transactionAmount;
  }

  public void setTransactionAmount(TransactionAmount transactionAmount) {
    this.transactionAmount = transactionAmount;
  }

  /**
   * A container for additional, undeclared properties.
   * This is a holder for any undeclared properties as specified with
   * the 'additionalProperties' keyword in the OAS document.
   */
  private Map<String, Object> additionalProperties;

  /**
   * Set the additional (undeclared) property with the specified name and value.
   * If the property does not already exist, create it otherwise replace it.
   *
   * @param key name of the property
   * @param value value of the property
   * @return the ConfirmationData instance itself
   */
  public ConfirmationData putAdditionalProperty(String key, Object value) {
    if (this.additionalProperties == null) {
        this.additionalProperties = new HashMap<String, Object>();
    }
    this.additionalProperties.put(key, value);
    return this;
  }

  /**
   * Return the additional (undeclared) property.
   *
   * @return a map of objects
   */
  public Map<String, Object> getAdditionalProperties() {
    return additionalProperties;
  }

  /**
   * Return the additional (undeclared) property with the specified name.
   *
   * @param key name of the property
   * @return an object
   */
  public Object getAdditionalProperty(String key) {
    if (this.additionalProperties == null) {
        return null;
    }
    return this.additionalProperties.get(key);
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ConfirmationData confirmationData = (ConfirmationData) o;
    return Objects.equals(this.checkoutEventType, confirmationData.checkoutEventType) &&
        Objects.equals(this.checkoutEventStatus, confirmationData.checkoutEventStatus) &&
        Objects.equals(this.confirmationStatus, confirmationData.confirmationStatus) &&
        Objects.equals(this.confirmationReason, confirmationData.confirmationReason) &&
        Objects.equals(this.confirmationTimestamp, confirmationData.confirmationTimestamp) &&
        Objects.equals(this.networkAuthorizationCode, confirmationData.networkAuthorizationCode) &&
        Objects.equals(this.networkTransactionIdentifier, confirmationData.networkTransactionIdentifier) &&
        Objects.equals(this.paymentNetworkReference, confirmationData.paymentNetworkReference) &&
        Objects.equals(this.assuranceData, confirmationData.assuranceData) &&
        Objects.equals(this.transactionAmount, confirmationData.transactionAmount)&&
        Objects.equals(this.additionalProperties, confirmationData.additionalProperties);
  }

  @Override
  public int hashCode() {
    return Objects.hash(checkoutEventType, checkoutEventStatus, confirmationStatus, confirmationReason, confirmationTimestamp, networkAuthorizationCode, networkTransactionIdentifier, paymentNetworkReference, assuranceData, transactionAmount, additionalProperties);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ConfirmationData {\n");
    sb.append("    checkoutEventType: ").append(toIndentedString(checkoutEventType)).append("\n");
    sb.append("    checkoutEventStatus: ").append(toIndentedString(checkoutEventStatus)).append("\n");
    sb.append("    confirmationStatus: ").append(toIndentedString(confirmationStatus)).append("\n");
    sb.append("    confirmationReason: ").append(toIndentedString(confirmationReason)).append("\n");
    sb.append("    confirmationTimestamp: ").append(toIndentedString(confirmationTimestamp)).append("\n");
    sb.append("    networkAuthorizationCode: ").append(toIndentedString(networkAuthorizationCode)).append("\n");
    sb.append("    networkTransactionIdentifier: ").append(toIndentedString(networkTransactionIdentifier)).append("\n");
    sb.append("    paymentNetworkReference: ").append(toIndentedString(paymentNetworkReference)).append("\n");
    sb.append("    assuranceData: ").append(toIndentedString(assuranceData)).append("\n");
    sb.append("    transactionAmount: ").append(toIndentedString(transactionAmount)).append("\n");
    sb.append("    additionalProperties: ").append(toIndentedString(additionalProperties)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("checkoutEventType");
    openapiFields.add("checkoutEventStatus");
    openapiFields.add("confirmationStatus");
    openapiFields.add("confirmationReason");
    openapiFields.add("confirmationTimestamp");
    openapiFields.add("networkAuthorizationCode");
    openapiFields.add("networkTransactionIdentifier");
    openapiFields.add("paymentNetworkReference");
    openapiFields.add("assuranceData");
    openapiFields.add("transactionAmount");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("checkoutEventType");
    openapiRequiredFields.add("checkoutEventStatus");
    openapiRequiredFields.add("confirmationTimestamp");
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to ConfirmationData
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ConfirmationData.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ConfirmationData is not found in the empty JSON string", ConfirmationData.openapiRequiredFields.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : ConfirmationData.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (!jsonObj.get("checkoutEventType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `checkoutEventType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("checkoutEventType").toString()));
      }
      if (!jsonObj.get("checkoutEventStatus").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `checkoutEventStatus` to be a primitive type in the JSON string but got `%s`", jsonObj.get("checkoutEventStatus").toString()));
      }
      if ((jsonObj.get("confirmationStatus") != null && !jsonObj.get("confirmationStatus").isJsonNull()) && !jsonObj.get("confirmationStatus").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `confirmationStatus` to be a primitive type in the JSON string but got `%s`", jsonObj.get("confirmationStatus").toString()));
      }
      if ((jsonObj.get("confirmationReason") != null && !jsonObj.get("confirmationReason").isJsonNull()) && !jsonObj.get("confirmationReason").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `confirmationReason` to be a primitive type in the JSON string but got `%s`", jsonObj.get("confirmationReason").toString()));
      }
      if (!jsonObj.get("confirmationTimestamp").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `confirmationTimestamp` to be a primitive type in the JSON string but got `%s`", jsonObj.get("confirmationTimestamp").toString()));
      }
      if ((jsonObj.get("networkAuthorizationCode") != null && !jsonObj.get("networkAuthorizationCode").isJsonNull()) && !jsonObj.get("networkAuthorizationCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `networkAuthorizationCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("networkAuthorizationCode").toString()));
      }
      if ((jsonObj.get("networkTransactionIdentifier") != null && !jsonObj.get("networkTransactionIdentifier").isJsonNull()) && !jsonObj.get("networkTransactionIdentifier").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `networkTransactionIdentifier` to be a primitive type in the JSON string but got `%s`", jsonObj.get("networkTransactionIdentifier").toString()));
      }
      if ((jsonObj.get("paymentNetworkReference") != null && !jsonObj.get("paymentNetworkReference").isJsonNull()) && !jsonObj.get("paymentNetworkReference").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `paymentNetworkReference` to be a primitive type in the JSON string but got `%s`", jsonObj.get("paymentNetworkReference").toString()));
      }
      // validate the optional field `assuranceData`
      if (jsonObj.get("assuranceData") != null && !jsonObj.get("assuranceData").isJsonNull()) {
        AssuranceData.validateJsonElement(jsonObj.get("assuranceData"));
      }
      // validate the optional field `transactionAmount`
      if (jsonObj.get("transactionAmount") != null && !jsonObj.get("transactionAmount").isJsonNull()) {
        TransactionAmount.validateJsonElement(jsonObj.get("transactionAmount"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ConfirmationData.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ConfirmationData' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ConfirmationData> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ConfirmationData.class));

       return (TypeAdapter<T>) new TypeAdapter<ConfirmationData>() {
           @Override
           public void write(JsonWriter out, ConfirmationData value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             obj.remove("additionalProperties");
             // serialize additional properties
             if (value.getAdditionalProperties() != null) {
               for (Map.Entry<String, Object> entry : value.getAdditionalProperties().entrySet()) {
                 if (entry.getValue() instanceof String)
                   obj.addProperty(entry.getKey(), (String) entry.getValue());
                 else if (entry.getValue() instanceof Number)
                   obj.addProperty(entry.getKey(), (Number) entry.getValue());
                 else if (entry.getValue() instanceof Boolean)
                   obj.addProperty(entry.getKey(), (Boolean) entry.getValue());
                 else if (entry.getValue() instanceof Character)
                   obj.addProperty(entry.getKey(), (Character) entry.getValue());
                 else {
                   JsonElement jsonElement = gson.toJsonTree(entry.getValue());
                   if (jsonElement.isJsonArray()) {
                     obj.add(entry.getKey(), jsonElement.getAsJsonArray());
                   } else {
                     obj.add(entry.getKey(), jsonElement.getAsJsonObject());
                   }
                 }
               }
             }
             elementAdapter.write(out, obj);
           }

           @Override
           public ConfirmationData read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             JsonObject jsonObj = jsonElement.getAsJsonObject();
             // store additional fields in the deserialized instance
             ConfirmationData instance = thisAdapter.fromJsonTree(jsonObj);
             for (Map.Entry<String, JsonElement> entry : jsonObj.entrySet()) {
               if (!openapiFields.contains(entry.getKey())) {
                 if (entry.getValue().isJsonPrimitive()) { // primitive type
                   if (entry.getValue().getAsJsonPrimitive().isString())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsString());
                   else if (entry.getValue().getAsJsonPrimitive().isNumber())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsNumber());
                   else if (entry.getValue().getAsJsonPrimitive().isBoolean())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsBoolean());
                   else
                     throw new IllegalArgumentException(String.format("The field `%s` has unknown primitive type. Value: %s", entry.getKey(), entry.getValue().toString()));
                 } else if (entry.getValue().isJsonArray()) {
                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), List.class));
                 } else { // JSON object
                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), HashMap.class));
                 }
               }
             }
             return instance;
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of ConfirmationData given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of ConfirmationData
  * @throws IOException if the JSON string is invalid with respect to ConfirmationData
  */
  public static ConfirmationData fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ConfirmationData.class);
  }

 /**
  * Convert an instance of ConfirmationData to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

